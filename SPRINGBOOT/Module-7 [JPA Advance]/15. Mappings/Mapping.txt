JPA/Hibernate :
@OneToOne(cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)  // Owning side
@JoinColumn(name = "user_address_id", referencedColumnName = "id")

@OneToOne(mappedBy = '', cascade = CascadeType.ALL) // Inverse side

===============================================================================================================

We can use below annotations for handling circular dependency in bidirectional mapping :
@JsonManagedReference: 
 * Marks the parent side of a relationship. It tells Hibernate/serialization that this side should be serialized normally.
@JsonBackReference: 
 * Marks the child side of a relationship. It tells Hibernate/serialization to ignore this side during serialization to prevent infinite loops.
@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id")
 * It assigns an ID when serializing an object.
 * If the same object appears again, it uses the ID instead of creating the full object again.
 * This avoids infinite recursion and reduces repeated data.

Note :
Always use DTO's.
Use separate DTO for separate request type.
Make use of Inheritance by creating DTO.

====================================================================================================================

* In JPA for update it first fetches the record from DB and the compares the current data and then does the query if needed.

Behind the scene of persist() and merge() :

persist()
 * With @GeneratedValue (Auto ID):
   * If you manually set ID ‚Üí ‚ùå Error: Hibernate says "ID should be generated by DB, don't provide it!"
   * If you don't set ID ‚Üí ‚úÖ Works fine, Hibernate asks DB to generate ID.

 * Without @GeneratedValue (Manual ID):
   * If you provide ID ‚Üí ‚úÖ Works fine, Hibernate uses your provided ID.
   * If you don't provide ID ‚Üí ‚ùå Error: Hibernate says "Where's the ID? I need it!"

merge()
 * Without @GeneratedValue (Manual ID):
   * If you provide ID ‚Üí Hibernate:
   * Tries to find it ‚Üí Updates if found.
   * If not found ‚Üí Creates new using your provided ID.
   * If you don't provide ID ‚Üí ‚ùå Error: Hibernate needs ID to work.

 * With @GeneratedValue (Auto ID):
   * If you provide ID[999] ‚Üí Hibernate thinks:
   * Hibernate sees an ID (999) provided.
     Hibernate tries to fetch the record with ID 999 from DB.
     It doesn't find any record (because 999 doesn't exist).
   Now Hibernate thinks:
    "Hmm, record with this ID doesn't exist, so should I treat it like a new record?"
    Yes, it treats it like a new record,
    but because the ID was already manually set, and the entity is annotated with @GeneratedValue,Hibernate gets confused:
       "I'm supposed to generate the ID myself, but user already gave ID![conflict]"
 
   üí• Result:
     Hibernate throws an error ‚Äî
     Saying something like:
      "Detached entity passed to persist: ID should not be manually assigned because it‚Äôs auto-generated."



=======================================
package com.example.dto;

public class CourseDTO {
    private Long id;
    private String courseName;
    private String instructorName;

    public CourseDTO(Long id, String courseName, String instructorName) {
        this.id = id;
        this.courseName = courseName;
        this.instructorName = instructorName;
    }

    // Getters, setters (optional if using for read-only)
}



public List<CourseDTO> getAllCourseDTOs() {
        String jpql = "SELECT new com.example.dto.CourseDTO(c.id, c.courseName, i.name) " +
                      "FROM Course c JOIN c.instructor i";
        return entityManager.createQuery(jpql, CourseDTO.class)
                            .getResultList();
    }
