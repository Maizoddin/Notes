When we add spring-security in our application, then each time we run the application it generates a new random password and username will be user.
[It comes from SecurityProperties.java]
private String name = "user";
private String password = UUID.randomUUID().toString();

HOW TO CHANGE DEFAULT USERNAME AND PASSWORD :
1] application.properties
   spring.security.user.name = john
   spring.security.user.password = pwd
 So now, it will use reflection and set this username and password in SecurityProperties.java

HOW TO CREATE MULTIPLE USERS ??

HIRARCHY :

UserDetailsService    # Interface [loadUserByUsername()]

UserDetailsManager    # Interface [createUser(), updateUser(), deleteUser(), changePassword(), userExists()]

InMemoryUserDetailsManager  # Class  [Implementation class. In constructor it takes UserDetails]
                                     [public InMemoryUserDetailsManager(Collection<UserDetails> users){}]


HERE UserDetails is an interface and User is an implementation class.

So To create multiple Users we should create the bean of InMemoryUserDetailsManager.
Code :
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public UserDetailsService userDetailsService(){
        UserDetails user1 = User.withUsername("Alex")
                .password("{noop}pwd")
                .roles("ADMIN")
                .build();
        UserDetails user2 = User.withUsername("Shane")
                .password("{brcypt}pwd")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user1, user2);
    }
}


NO MATTER WHERE WE ARE STORING PASSWORD IT SHOULD HAVE THE HASHING ALGORITHM SPECIFIED WITH IT. SO THAT WHILE AUTHENTICATING IT CAN USE THAT ALGORITHM TO COMPARE THE PASSWORD
Format : {id}password
Example :
{noop}  -> No encoding No hashing
{bcrypt} -> One way hashing
{sha256}

Encoders :
DelegatingPasswordEncoder  -> [Default] It checks the {id} and delegates it to appropriate encoder
BcryptPasswordEncoder
NoOpPasswordEncoder
...


SCENARIO 1] {noop}
User enter's username and password then DelegatingPasswordEncoder   will delegate it to NoOpPasswordEncoder so it will compare the stored password and entered password.

SCENARIO 2] {bcrypt}
User enter's username and password then DelegatingPasswordEncoder   will delegate it to  BcryptPasswordEncoder so it will encode the entered password and compares it with the stored one.

HOW CAN WE AVOID ADDING {id} ???
By default spring uses DelegatingPasswordEncoder which need's {id} to delegate it to appropriate encoder. so now we can create bean of our encoder then spring will use our specifies encoder bean.

Code :
    @Bean
    public UserDetailsService userDetailsService(){
        UserDetails user1 = User.withUsername("maaz")
                .password(new BCryptPasswordEncoder().encode("pwd"))
                .roles("ADMIN")
                .build();
        UserDetails user2 = User.withUsername("sakib")
                .password(new BCryptPasswordEncoder().encode("pwd"))
                .roles("USER")
                .build();
        return new InMemoryUserDetailsManager(user1, user2);
    }

    @Bean
    public PasswordEncoder passwordEncoder(){
        return  new BCryptPasswordEncoder();
    }



FOR PRODUCTION ITS RECOMMENDED TO STORE AND FETCH THE USER DETAILS FROM DATABASE.
So our Entity class should implement the UserDetails because during authentication spring will fetch the user and returns the object of UserDetails. and
Service class should implement UserDetailsService and override loadUserByUsername()

  


